
import matplotlib.pyplot as plt
import numpy as np
from matplotlib.animation import FuncAnimation
from matplotlib.axes import Axes
from typing import Optional, Tuple
from numpy.typing import ArrayLike, NDArray


def plot_quiver_field(
    X: ArrayLike,
    Y: ArrayLike,
    Ux: ArrayLike,
    Uy: ArrayLike,
    *,
    mask_center: Optional[Tuple[float, float]] = None,
    mask_radius: float = 0.05,
    step: int = 4,
    scale: Optional[float] = None,
    title: Optional[str] = None,
    figsize: Tuple[float, float] = (6, 6),
) -> Axes:
    """
    Plot a 2D vector field using a quiver plot.

    Parameters
    ----------
    X, Y : array-like, shape (Ny, Nx)
        Meshgrid arrays specifying the spatial coordinates.
        Typically generated by `np.meshgrid`.

    Ux, Uy : array-like, shape (Ny, Nx)
        Velocity components evaluated on the grid.
        `Ux[i, j]` and `Uy[i, j]` give the vector at `(X[i, j], Y[i, j])`.

    mask_center : (float, float), optional
        If provided, vectors inside a circular region centered at
        `(x0, y0)` are masked (not plotted).

    mask_radius : float, default=0.05
        Radius of the circular mask region, in data units.

    step : int, default=4
        Subsampling factor for the quiver plot.
        Only every `step`-th grid point is plotted in each direction.

    scale : float or None, optional
        Scaling factor passed directly to `matplotlib.axes.Axes.quiver`.
        If None, Matplotlib chooses an automatic scale.

    title : str or None, optional
        Title for the plot.

    figsize : (float, float), default=(6, 6)
        Size of the figure in inches.

    Returns
    -------
    ax : matplotlib.axes.Axes
        The axes object containing the quiver plot.

    Notes
    -----
    - The plot uses `angles="xy"` and `scale_units="xy"`, so vectors are
      interpreted in data coordinates.
    - The axes aspect ratio is set to `"equal"` so that vector directions
      are not visually distorted.
    - Masking is applied by converting `Ux` and `Uy` to masked arrays;
      the original inputs are not modified.
    """
    X, Y, Ux, Uy = map(np.asarray, (X, Y, Ux, Uy))

    if mask_center is not None:
        x0, y0 = mask_center
        mask = (X - x0)**2 + (Y - y0)**2 < mask_radius**2
        Ux = np.ma.array(Ux, mask=mask)
        Uy = np.ma.array(Uy, mask=mask)

    fig, ax = plt.subplots(figsize=figsize)
    ax.set_aspect("equal", adjustable="box")

    ax.quiver(
        X[::step, ::step], Y[::step, ::step],
        Ux[::step, ::step], Uy[::step, ::step],
        angles="xy",
        scale_units="xy",
        scale=scale,
        width=0.003
    )

    ax.set_xlabel("x")
    ax.set_ylabel("y")
    if title:
        ax.set_title(title)

    plt.tight_layout()
    plt.show()
    
    return ax

def plot_streamlines(
    X: ArrayLike,
    Y: ArrayLike,
    Ux: ArrayLike,
    Uy: ArrayLike,
    *,
    mask_center: Optional[Tuple[float, float]] = None,
    mask_radius: float = 0.05,
    density: float = 1.3,
    linewidth: float = 1.0,
    color_by_speed: bool = True,
    title: Optional[str] = None,
    figsize: Tuple[float, float] = (6, 6),
) -> Axes:
    """
    Plot streamlines of a 2D vector field.

    Parameters
    ----------
    X, Y : array-like, shape (Ny, Nx)
        Meshgrid arrays specifying the spatial coordinates.
        Typically generated by `np.meshgrid`.

    Ux, Uy : array-like, shape (Ny, Nx)
        Velocity components evaluated on the grid.
        `Ux[i, j]` and `Uy[i, j]` give the vector at `(X[i, j], Y[i, j])`.

    mask_center : (float, float), optional
        If provided, streamlines inside a circular region centered at
        `(x0, y0)` are masked (not plotted).

    mask_radius : float, default=0.05
        Radius of the circular mask region, in data units.

    density : float, default=1.3
        Controls the closeness of streamlines.
        Higher values produce more densely packed streamlines.

    linewidth : float, default=1.0
        Line width of the streamlines.

    color_by_speed : bool, default=True
        If True, streamlines are colored by the local speed
        `sqrt(Ux**2 + Uy**2)`. If False, streamlines use a single default color.

    title : str or None, optional
        Title for the plot.

    figsize : (float, float), default=(6, 6)
        Size of the figure in inches.

    Returns
    -------
    ax : matplotlib.axes.Axes
        The axes object containing the streamline plot.

    Notes
    -----
    - The axes aspect ratio is set to `"equal"` so that streamlines are not
      visually distorted.
    - Masking is applied by converting the velocity components and speed
      to masked arrays; the original input arrays are not modified.
    - Streamlines are generated using `matplotlib.axes.Axes.streamplot`,
      which performs internal interpolation on the supplied grid.
    """
    X, Y, Ux, Uy = map(np.asarray, (X, Y, Ux, Uy))
    speed = np.sqrt(Ux**2 + Uy**2)

    if mask_center is not None:
        x0, y0 = mask_center
        mask = (X - x0)**2 + (Y - y0)**2 < mask_radius**2
        Ux = np.ma.array(Ux, mask=mask)
        Uy = np.ma.array(Uy, mask=mask)
        speed = np.ma.array(speed, mask=mask)

    fig, ax = plt.subplots(figsize=figsize)
    ax.set_aspect("equal", adjustable="box")

    ax.streamplot(
        X, Y, Ux, Uy,
        density=density,
        linewidth=linewidth,
        arrowsize=1.2,
        color=speed if color_by_speed else None
    )

    ax.set_xlabel("x")
    ax.set_ylabel("y")
    if title:
        ax.set_title(title)

    plt.tight_layout()
    plt.show()

    return ax

def plot_oriented_trajectory(
    x: np.ndarray,
    theta: np.ndarray,
    *,
    n_arrows: int = 20,
    arrow_length: float = 0.15,
    marker_size: float = 200,
    ax: Axes | None = None,
    color: str = "black",
    label: str | None = None,
):
    """
    Plot a particle trajectory with orientation arrows.

    Parameters
    ----------
    x : (T, 2) ndarray
        Trajectory positions.
    theta : (T,) ndarray
        Orientation angles (radians).
    n_arrows : int
        Number of orientation arrows drawn along the trajectory.
    arrow_length : float
        Length of orientation arrows in data units.
    marker_size : float
        Size of the circular particle markers.
    ax : matplotlib.axes.Axes or None
        Axes to draw on. If None, a new figure is created.
    color : str
        Color of trajectory and arrows.
    label : str or None
        Optional label for legend.

    Returns
    -------
    ax : matplotlib.axes.Axes
        The axes the plot was drawn on.
    """

    if ax is None:
        fig, ax = plt.subplots(figsize=(6, 6))

    x = np.asarray(x)
    theta = np.asarray(theta)

    assert x.ndim == 2 and x.shape[1] == 2, "x must have shape (T, 2)"
    assert theta.ndim == 1 and len(theta) == len(x), "theta must have shape (T,)"

    T = len(x)

    # Plot trajectory line
    ax.plot(x[:, 0], x[:, 1], color=color, lw=2, label=label)

    # Choose indices for orientation arrows
    if n_arrows >= T:
        idx = np.arange(T)
    else:
        idx = np.linspace(0, T - 1, n_arrows, dtype=int)

    # Circle markers
    ax.scatter(
        x[idx, 0],
        x[idx, 1],
        s=marker_size,
        facecolor="white",
        edgecolor=color,
        zorder=3,
    )

    # Orientation arrows
    ux = np.cos(theta[idx])
    uy = np.sin(theta[idx])

    ax.quiver(
        x[idx, 0],
        x[idx, 1],
        ux,
        uy,
        angles="xy",
        scale_units="xy",
        scale=1 / arrow_length,
        width=0.003,
        color=color,
        zorder=4,
    )

    # ax.set_aspect("equal", adjustable="box")
    ax.set_xlabel("x")
    ax.set_ylabel("y")

    return ax
